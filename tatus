[1mdiff --git a/EBus/EBus/EBus.csproj b/EBus/EBus/EBus.csproj[m
[1mindex 04abdfc..42400e7 100644[m
[1m--- a/EBus/EBus/EBus.csproj[m
[1m+++ b/EBus/EBus/EBus.csproj[m
[36m@@ -8,7 +8,7 @@[m
 	<GeneratePackageOnBuild>true</GeneratePackageOnBuild>[m
 [m
 	<PackageId>EBus</PackageId>[m
[31m-	<Version>1.0.0</Version>[m
[32m+[m	[32m<Version>1.1.0</Version>[m
 	<Authors>Martin MuharemoviÄ‡</Authors>[m
 	<Description>[m
 		EBus: A lightweight mediator library that supports CQRS and notifications,[m
[1mdiff --git a/EBus/EBus/Registration/ServiceCollectionExtensions.cs b/EBus/EBus/Registration/ServiceCollectionExtensions.cs[m
[1mindex 27198dd..1f915fe 100644[m
[1m--- a/EBus/EBus/Registration/ServiceCollectionExtensions.cs[m
[1m+++ b/EBus/EBus/Registration/ServiceCollectionExtensions.cs[m
[36m@@ -11,8 +11,9 @@[m [mnamespace EBus.Registration;[m
 public static class ServiceCollectionExtensions[m
 {[m
     /// <summary>[m
[31m-    /// Scans the given assemblies, registers all IRequestHandler<,>, INotificationHandler<>, [m
[31m-    /// and IPipelineBehavior<,> implementations, and registers the EBus Mediator itself.[m
[32m+[m[32m    /// Scan *exactly* the assemblies you pass in, register all IRequestHandler<,>,[m
[32m+[m[32m    /// INotificationHandler<>, and IPipelineBehavior<,> found in those assemblies,[m
[32m+[m[32m    /// then register the EBus Mediator itself.[m
     /// </summary>[m
     /// <param name="services">The IServiceCollection to add to.</param>[m
     /// <param name="assemblies">[m
[36m@@ -22,17 +23,52 @@[m [mpublic static class ServiceCollectionExtensions[m
     /// <returns>The IServiceCollection, for chaining.</returns>[m
     public static IServiceCollection AddEBus(this IServiceCollection services, params Assembly[] assemblies)[m
     {[m
[31m-        if (assemblies == null || assemblies.Length == 0) throw new ArgumentException("You must provide at least one assembly to scan.", nameof(assemblies));[m
[32m+[m[32m        if (assemblies == null || assemblies.Length == 0)[m
[32m+[m[32m            throw new ArgumentException("You must provide at least one assembly to scan.", nameof(assemblies));[m
 [m
         services.AddTransient<IMediator, Mediator>();[m
 [m
         RegisterRequestHandlers(services, assemblies);[m
         RegisterNotificationHandlers(services, assemblies);[m
[31m-        RegisterPipelineBehaviours(services, assemblies);[m
[32m+[m[32m        RegisterPipelineBehaviors(services, assemblies);[m
 [m
         return services;[m
     }[m
 [m
[32m+[m[32m    /// <summary>[m
[32m+[m[32m    /// Scan the entry assembly plus all of its referenced assemblies,[m
[32m+[m[32m    /// registers all IRequestHandler<,>, INotificationHandler<>, and IPipelineBehavior<,> implementations[m
[32m+[m[32m    /// found in those assemblies, and then registers the EBus Mediator itself.[m
[32m+[m[32m    /// </summary>[m
[32m+[m[32m    public static IServiceCollection AddEBus(this IServiceCollection services)[m
[32m+[m[32m    {[m
[32m+[m[32m        var entryAssembly = Assembly.GetEntryAssembly();[m
[32m+[m[32m        if (entryAssembly == null)[m
[32m+[m[32m            throw new InvalidOperationException("Could not determine entry assembly.");[m
[32m+[m
[32m+[m[32m        var toScan = new List<Assembly> { entryAssembly };[m
[32m+[m
[32m+[m[32m        foreach (var asmName in entryAssembly.GetReferencedAssemblies())[m
[32m+[m[32m        {[m
[32m+[m[32m            try[m
[32m+[m[32m            {[m
[32m+[m[32m                var loaded = Assembly.Load(asmName);[m
[32m+[m[32m                toScan.Add(loaded);[m
[32m+[m[32m            }[m
[32m+[m[32m            catch[m
[32m+[m[32m            {[m
[32m+[m[32m                // If it fails to load, ignore (e.g. dynamic or unrelated system assemblies)[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        var distinct = toScan[m
[32m+[m[32m            .Where(a => a != null)[m
[32m+[m[32m            .Distinct()[m
[32m+[m[32m            .ToArray();[m
[32m+[m
[32m+[m[32m        return services.AddEBus(distinct);[m
[32m+[m[32m    }[m
[32m+[m
     private static void RegisterRequestHandlers(IServiceCollection services, Assembly[] assemblies)[m
     {[m
         var openInterfaceType = typeof(IRequestHandler<,>);[m
[36m@@ -75,21 +111,21 @@[m [mpublic static class ServiceCollectionExtensions[m
         }[m
     }[m
 [m
[31m-    private static void RegisterPipelineBehaviours(IServiceCollection services, Assembly[] assemblies)[m
[32m+[m[32m    private static void RegisterPipelineBehaviors(IServiceCollection services, Assembly[] assemblies)[m
     {[m
         var openInterfaceType = typeof(IPipelineBehaviour<,>);[m
 [m
[31m-        foreach (var assembbly in assemblies)[m
[32m+[m[32m        foreach (var assembly in assemblies)[m
         {[m
[31m-            var types = assembbly[m
[32m+[m[32m            var implementations = assembly[m
                 .GetTypes()[m
                 .Where(t => !t.IsInterface && !t.IsAbstract)[m
                 .SelectMany(t => t.GetInterfaces()[m
[31m-                    .Where(i => i.IsGenericType &&[m
[31m-                           i.GetGenericTypeDefinition() == openInterfaceType)[m
[31m-                    .Select(i => new { Implementation = t, Service = i })[m
[31m-                );[m
[31m-            foreach (var pair in types)[m
[32m+[m[32m                    .Where(i => i.IsGenericType[m
[32m+[m[32m                                && i.GetGenericTypeDefinition() == openInterfaceType)[m
[32m+[m[32m                    .Select(i => new { Service = i, Implementation = t }));[m
[32m+[m
[32m+[m[32m            foreach (var pair in implementations)[m
             {[m
                 services.AddTransient(pair.Service, pair.Implementation);[m
             }[m
[1mdiff --git a/README.md b/README.md[m
[1mindex 0ddcb0e..0938ea3 100644[m
[1m--- a/README.md[m
[1m+++ b/README.md[m
[36m@@ -24,8 +24,6 @@[m [mEBus resolves handlers and behaviors at runtime using generic interfaces and C#[m
   - [Sending a Request](#sending-a-request)  [m
   - [Publishing a Notification](#publishing-a-notification)  [m
   - [Registering Multiple Assemblies](#registering-multiple-assemblies)  [m
[31m-- [Packaging & Publishing](#packaging--publishing)  [m
[31m-- [Versioning & Maintenance](#versioning--maintenance)  [m
 - [Contributing](#contributing)  [m
 - [License](#license)  [m
 [m
